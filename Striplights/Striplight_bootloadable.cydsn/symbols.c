
#include <project.h>
#include "shared.h"

#define INVADER_FRAME_COUNT 2
#define INVADER_FRAME_WIDTH 12
#define INVADER_FRAME_HEIGHT 12

/* Piskel data for "invader" */

static const uint32_t invader_data[2][144] = {
{
0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 
0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 
0x000000, 0x000000, 0x000000, 0x00c93b, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x00c93b, 0x000000, 0x000000, 
0x000000, 0x000000, 0x000000, 0x000000, 0x00c93b, 0x000000, 0x000000, 0x000000, 0x00c93b, 0x000000, 0x000000, 0x000000, 
0x000000, 0x000000, 0x000000, 0x00c93b, 0x00c93b, 0x00c93b, 0x00c93b, 0x00c93b, 0x00c93b, 0x00c93b, 0x000000, 0x000000, 
0x000000, 0x000000, 0x00c93b, 0x00c93b, 0x000000, 0x00c93b, 0x00c93b, 0x00c93b, 0x000000, 0x00c93b, 0x00c93b, 0x000000, 
0x000000, 0x00c93b, 0x00c93b, 0x00c93b, 0x00c93b, 0x00c93b, 0x00c93b, 0x00c93b, 0x00c93b, 0x00c93b, 0x00c93b, 0x00c93b, 
0x000000, 0x00c93b, 0x000000, 0x00c93b, 0x00c93b, 0x00c93b, 0x00c93b, 0x00c93b, 0x00c93b, 0x00c93b, 0x000000, 0x00c93b, 
0x000000, 0x00c93b, 0x000000, 0x00c93b, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x00c93b, 0x000000, 0x00c93b, 
0x000000, 0x000000, 0x000000, 0x000000, 0x00c93b, 0x00c93b, 0x000000, 0x00c93b, 0x00c93b, 0x000000, 0x000000, 0x000000, 
0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 
0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000
},
{
0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 
0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 
0x000000, 0x000000, 0x000000, 0x00c93b, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x00c93b, 0x000000, 0x000000, 
0x000000, 0x00c93b, 0x000000, 0x000000, 0x00c93b, 0x000000, 0x000000, 0x000000, 0x00c93b, 0x000000, 0x000000, 0x00c93b, 
0x000000, 0x00c93b, 0x000000, 0x00c93b, 0x00c93b, 0x00c93b, 0x00c93b, 0x00c93b, 0x00c93b, 0x00c93b, 0x000000, 0x00c93b, 
0x000000, 0x00c93b, 0x00c93b, 0x00c93b, 0x000000, 0x00c93b, 0x00c93b, 0x00c93b, 0x000000, 0x00c93b, 0x00c93b, 0x00c93b, 
0x000000, 0x000000, 0x00c93b, 0x00c93b, 0x00c93b, 0x00c93b, 0x00c93b, 0x00c93b, 0x00c93b, 0x00c93b, 0x00c93b, 0x000000, 
0x000000, 0x000000, 0x000000, 0x00c93b, 0x00c93b, 0x00c93b, 0x00c93b, 0x00c93b, 0x00c93b, 0x00c93b, 0x000000, 0x000000, 
0x000000, 0x000000, 0x000000, 0x00c93b, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x00c93b, 0x000000, 0x000000, 
0x000000, 0x000000, 0x00c93b, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x00c93b, 0x000000, 
0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 
0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000
}
};

struct symbol {
	int frame_count;
	int width;
	int height;
	uint32_t refresh_time;
	uint32_t *data;
};

#define SYM_COUNT	3

static const struct symbol syms[SYM_COUNT] = {
	{ INVADER_FRAME_COUNT, INVADER_FRAME_WIDTH, INVADER_FRAME_HEIGHT, 1000, (void *) invader_data }
};

static void
draw_symbol(const struct symbol *sym, int frame)
{
	int x, y;
	int frame_off = (frame * sym->width * sym->height);
	uint32_t color;

	while(StripLights_Ready() == 0);
	for (x = 0; x < sym->width; x++) {
		for (y = 0; y < sym->height; y++) {
			color = sym->data[frame_off + x * sym->width + y];
			color = ((color >> 8) & 0xFFFF) | ((color & 0xFF) << 16 );
			set_pixel(x, y, color);
		}
	}
	StripLights_Trigger(1);
}

void
symbol_mode()
{
	int cur_sym = 0, old_sym = -1;
	uint8_t reg_status;
	const struct symbol *sym = NULL;
	uint32_t last_update_time = 0;
	int cur_frame = 0;

	do {
		cur_sym += get_rot1_dir();
		FILTER_VALUE(cur_sym, SYM_COUNT - 1);

		if (cur_sym != old_sym) {
			sym = &syms[cur_sym];
			draw_symbol(sym, 0);
			cur_frame = 0;
		}
		
		/* Refresh if there is a refresh time set and timer expire*/
		if (sym->refresh_time &&
			(ms_count - last_update_time) > sym->refresh_time) {

			draw_symbol(sym, cur_frame);

			cur_frame = (cur_frame + 1) % sym->frame_count;
			last_update_time = ms_count;
		}
		
		old_sym = cur_sym;

		reg_status = RotSWReg_Read();
	} while(reg_status != 0);
}
